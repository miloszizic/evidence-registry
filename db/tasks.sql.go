// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: tasks.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createCalendarEvent = `-- name: CreateCalendarEvent :one
INSERT INTO "calendar_events" (
  id,
  user_id,
  case_id,
  event_date,
  notes,
  task_id
) VALUES (
  $1, $2, $3, $4, $5, $6
) RETURNING id, user_id, case_id, event_date, notes, task_id
`

type CreateCalendarEventParams struct {
	ID        uuid.UUID      `json:"id"`
	UserID    uuid.UUID      `json:"user_id"`
	CaseID    uuid.UUID      `json:"case_id"`
	EventDate time.Time      `json:"event_date"`
	Notes     sql.NullString `json:"notes"`
	TaskID    uuid.NullUUID  `json:"task_id"`
}

func (q *Queries) CreateCalendarEvent(ctx context.Context, arg CreateCalendarEventParams) (CalendarEvent, error) {
	row := q.db.QueryRowContext(ctx, createCalendarEvent,
		arg.ID,
		arg.UserID,
		arg.CaseID,
		arg.EventDate,
		arg.Notes,
		arg.TaskID,
	)
	var i CalendarEvent
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CaseID,
		&i.EventDate,
		&i.Notes,
		&i.TaskID,
	)
	return i, err
}

const createTask = `-- name: CreateTask :one

INSERT INTO "tasks" (
  name,
  description,
  task_type_id,
  case_id
) VALUES (
  $1, $2, $3, $4
) RETURNING id, name, description, task_type_id, case_id
`

type CreateTaskParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	TaskTypeID  uuid.UUID      `json:"task_type_id"`
	CaseID      uuid.NullUUID  `json:"case_id"`
}

// Tasks
func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, createTask,
		arg.Name,
		arg.Description,
		arg.TaskTypeID,
		arg.CaseID,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.TaskTypeID,
		&i.CaseID,
	)
	return i, err
}

const createTaskReschedule = `-- name: CreateTaskReschedule :one
INSERT INTO "task_reschedules" (
  user_task_id,
  new_due_date,
  reassigned_to,
  comment,
  rescheduled_by
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING id, user_task_id, new_due_date, reassigned_to, comment, rescheduled_by
`

type CreateTaskRescheduleParams struct {
	UserTaskID    uuid.UUID      `json:"user_task_id"`
	NewDueDate    time.Time      `json:"new_due_date"`
	ReassignedTo  uuid.NullUUID  `json:"reassigned_to"`
	Comment       sql.NullString `json:"comment"`
	RescheduledBy uuid.UUID      `json:"rescheduled_by"`
}

func (q *Queries) CreateTaskReschedule(ctx context.Context, arg CreateTaskRescheduleParams) (TaskReschedule, error) {
	row := q.db.QueryRowContext(ctx, createTaskReschedule,
		arg.UserTaskID,
		arg.NewDueDate,
		arg.ReassignedTo,
		arg.Comment,
		arg.RescheduledBy,
	)
	var i TaskReschedule
	err := row.Scan(
		&i.ID,
		&i.UserTaskID,
		&i.NewDueDate,
		&i.ReassignedTo,
		&i.Comment,
		&i.RescheduledBy,
	)
	return i, err
}

const createTaskType = `-- name: CreateTaskType :one
INSERT INTO "task_types" (
  name
) VALUES (
  $1
) RETURNING id, name
`

func (q *Queries) CreateTaskType(ctx context.Context, name string) (TaskType, error) {
	row := q.db.QueryRowContext(ctx, createTaskType, name)
	var i TaskType
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const createUserTask = `-- name: CreateUserTask :one
INSERT INTO "user_tasks" (
  user_id,
  task_id,
  assigned_by,
  due_date,
  is_completed,
  reschedule_count
) VALUES (
  $1, $2, $3, $4, $5, $6
) RETURNING id, user_id, task_id, assigned_by, due_date, is_completed, reschedule_count
`

type CreateUserTaskParams struct {
	UserID          uuid.UUID     `json:"user_id"`
	TaskID          uuid.UUID     `json:"task_id"`
	AssignedBy      uuid.UUID     `json:"assigned_by"`
	DueDate         time.Time     `json:"due_date"`
	IsCompleted     sql.NullBool  `json:"is_completed"`
	RescheduleCount sql.NullInt32 `json:"reschedule_count"`
}

func (q *Queries) CreateUserTask(ctx context.Context, arg CreateUserTaskParams) (UserTask, error) {
	row := q.db.QueryRowContext(ctx, createUserTask,
		arg.UserID,
		arg.TaskID,
		arg.AssignedBy,
		arg.DueDate,
		arg.IsCompleted,
		arg.RescheduleCount,
	)
	var i UserTask
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TaskID,
		&i.AssignedBy,
		&i.DueDate,
		&i.IsCompleted,
		&i.RescheduleCount,
	)
	return i, err
}

const deleteTaskReschedule = `-- name: DeleteTaskReschedule :exec
DELETE FROM "task_reschedules" WHERE id = $1
`

func (q *Queries) DeleteTaskReschedule(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteTaskReschedule, id)
	return err
}

const deleteUserTask = `-- name: DeleteUserTask :exec
DELETE FROM "user_tasks" WHERE id = $1
`

func (q *Queries) DeleteUserTask(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUserTask, id)
	return err
}

const getCalendarEvent = `-- name: GetCalendarEvent :one
SELECT id, user_id, case_id, event_date, notes, task_id FROM "calendar_events" WHERE id = $1
`

func (q *Queries) GetCalendarEvent(ctx context.Context, id uuid.UUID) (CalendarEvent, error) {
	row := q.db.QueryRowContext(ctx, getCalendarEvent, id)
	var i CalendarEvent
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CaseID,
		&i.EventDate,
		&i.Notes,
		&i.TaskID,
	)
	return i, err
}

const getCalendarEventsByUserId = `-- name: GetCalendarEventsByUserId :many
SELECT id, user_id, case_id, event_date, notes, task_id FROM "calendar_events" WHERE user_id = $1
`

func (q *Queries) GetCalendarEventsByUserId(ctx context.Context, userID uuid.UUID) ([]CalendarEvent, error) {
	rows, err := q.db.QueryContext(ctx, getCalendarEventsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CalendarEvent{}
	for rows.Next() {
		var i CalendarEvent
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CaseID,
			&i.EventDate,
			&i.Notes,
			&i.TaskID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTask = `-- name: GetTask :one
SELECT id, name, description, task_type_id, case_id FROM "tasks" WHERE id = $1
`

func (q *Queries) GetTask(ctx context.Context, id uuid.UUID) (Task, error) {
	row := q.db.QueryRowContext(ctx, getTask, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.TaskTypeID,
		&i.CaseID,
	)
	return i, err
}

const getTaskReschedule = `-- name: GetTaskReschedule :one
SELECT id, user_task_id, new_due_date, reassigned_to, comment, rescheduled_by FROM "task_reschedules" WHERE id = $1
`

func (q *Queries) GetTaskReschedule(ctx context.Context, id uuid.UUID) (TaskReschedule, error) {
	row := q.db.QueryRowContext(ctx, getTaskReschedule, id)
	var i TaskReschedule
	err := row.Scan(
		&i.ID,
		&i.UserTaskID,
		&i.NewDueDate,
		&i.ReassignedTo,
		&i.Comment,
		&i.RescheduledBy,
	)
	return i, err
}

const getTaskType = `-- name: GetTaskType :one
SELECT id, name FROM "task_types" WHERE id = $1
`

func (q *Queries) GetTaskType(ctx context.Context, id uuid.UUID) (TaskType, error) {
	row := q.db.QueryRowContext(ctx, getTaskType, id)
	var i TaskType
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getUserTask = `-- name: GetUserTask :one
SELECT id, user_id, task_id, assigned_by, due_date, is_completed, reschedule_count FROM "user_tasks" WHERE id = $1
`

func (q *Queries) GetUserTask(ctx context.Context, id uuid.UUID) (UserTask, error) {
	row := q.db.QueryRowContext(ctx, getUserTask, id)
	var i UserTask
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TaskID,
		&i.AssignedBy,
		&i.DueDate,
		&i.IsCompleted,
		&i.RescheduleCount,
	)
	return i, err
}

const getUserTasksByUserId = `-- name: GetUserTasksByUserId :many
SELECT id, user_id, task_id, assigned_by, due_date, is_completed, reschedule_count FROM "user_tasks" WHERE user_id = $1
`

func (q *Queries) GetUserTasksByUserId(ctx context.Context, userID uuid.UUID) ([]UserTask, error) {
	rows, err := q.db.QueryContext(ctx, getUserTasksByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserTask{}
	for rows.Next() {
		var i UserTask
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TaskID,
			&i.AssignedBy,
			&i.DueDate,
			&i.IsCompleted,
			&i.RescheduleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCalendarEvents = `-- name: ListCalendarEvents :many
SELECT id, user_id, case_id, event_date, notes, task_id FROM "calendar_events"
`

func (q *Queries) ListCalendarEvents(ctx context.Context) ([]CalendarEvent, error) {
	rows, err := q.db.QueryContext(ctx, listCalendarEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CalendarEvent{}
	for rows.Next() {
		var i CalendarEvent
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CaseID,
			&i.EventDate,
			&i.Notes,
			&i.TaskID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTaskReschedules = `-- name: ListTaskReschedules :many
SELECT id, user_task_id, new_due_date, reassigned_to, comment, rescheduled_by FROM "task_reschedules"
`

func (q *Queries) ListTaskReschedules(ctx context.Context) ([]TaskReschedule, error) {
	rows, err := q.db.QueryContext(ctx, listTaskReschedules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskReschedule{}
	for rows.Next() {
		var i TaskReschedule
		if err := rows.Scan(
			&i.ID,
			&i.UserTaskID,
			&i.NewDueDate,
			&i.ReassignedTo,
			&i.Comment,
			&i.RescheduledBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTaskTypes = `-- name: ListTaskTypes :many
SELECT id, name FROM "task_types"
`

func (q *Queries) ListTaskTypes(ctx context.Context) ([]TaskType, error) {
	rows, err := q.db.QueryContext(ctx, listTaskTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskType{}
	for rows.Next() {
		var i TaskType
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
SELECT id, name, description, task_type_id, case_id FROM "tasks"
`

func (q *Queries) ListTasks(ctx context.Context) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.TaskTypeID,
			&i.CaseID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserTasks = `-- name: ListUserTasks :many
SELECT id, user_id, task_id, assigned_by, due_date, is_completed, reschedule_count FROM "user_tasks"
`

func (q *Queries) ListUserTasks(ctx context.Context) ([]UserTask, error) {
	rows, err := q.db.QueryContext(ctx, listUserTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserTask{}
	for rows.Next() {
		var i UserTask
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TaskID,
			&i.AssignedBy,
			&i.DueDate,
			&i.IsCompleted,
			&i.RescheduleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const taskRescheduleExists = `-- name: TaskRescheduleExists :one
SELECT EXISTS(SELECT 1 FROM "task_reschedules" WHERE id = $1)
`

func (q *Queries) TaskRescheduleExists(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, taskRescheduleExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateTaskReschedule = `-- name: UpdateTaskReschedule :one
UPDATE "task_reschedules"
SET
  user_task_id = $2,
  new_due_date = $3,
  reassigned_to = $4,
  comment = $5,
  rescheduled_by = $6
WHERE id = $1
RETURNING id, user_task_id, new_due_date, reassigned_to, comment, rescheduled_by
`

type UpdateTaskRescheduleParams struct {
	ID            uuid.UUID      `json:"id"`
	UserTaskID    uuid.UUID      `json:"user_task_id"`
	NewDueDate    time.Time      `json:"new_due_date"`
	ReassignedTo  uuid.NullUUID  `json:"reassigned_to"`
	Comment       sql.NullString `json:"comment"`
	RescheduledBy uuid.UUID      `json:"rescheduled_by"`
}

func (q *Queries) UpdateTaskReschedule(ctx context.Context, arg UpdateTaskRescheduleParams) (TaskReschedule, error) {
	row := q.db.QueryRowContext(ctx, updateTaskReschedule,
		arg.ID,
		arg.UserTaskID,
		arg.NewDueDate,
		arg.ReassignedTo,
		arg.Comment,
		arg.RescheduledBy,
	)
	var i TaskReschedule
	err := row.Scan(
		&i.ID,
		&i.UserTaskID,
		&i.NewDueDate,
		&i.ReassignedTo,
		&i.Comment,
		&i.RescheduledBy,
	)
	return i, err
}

const updateUserTask = `-- name: UpdateUserTask :one
UPDATE "user_tasks"
SET
  user_id = $2,
  task_id = $3,
  assigned_by = $4,
  due_date = $5,
  is_completed = $6,
  reschedule_count = $7
WHERE id = $1
RETURNING id, user_id, task_id, assigned_by, due_date, is_completed, reschedule_count
`

type UpdateUserTaskParams struct {
	ID              uuid.UUID     `json:"id"`
	UserID          uuid.UUID     `json:"user_id"`
	TaskID          uuid.UUID     `json:"task_id"`
	AssignedBy      uuid.UUID     `json:"assigned_by"`
	DueDate         time.Time     `json:"due_date"`
	IsCompleted     sql.NullBool  `json:"is_completed"`
	RescheduleCount sql.NullInt32 `json:"reschedule_count"`
}

func (q *Queries) UpdateUserTask(ctx context.Context, arg UpdateUserTaskParams) (UserTask, error) {
	row := q.db.QueryRowContext(ctx, updateUserTask,
		arg.ID,
		arg.UserID,
		arg.TaskID,
		arg.AssignedBy,
		arg.DueDate,
		arg.IsCompleted,
		arg.RescheduleCount,
	)
	var i UserTask
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TaskID,
		&i.AssignedBy,
		&i.DueDate,
		&i.IsCompleted,
		&i.RescheduleCount,
	)
	return i, err
}

const userTaskExists = `-- name: UserTaskExists :one
SELECT EXISTS(SELECT 1 FROM "user_tasks" WHERE id = $1)
`

func (q *Queries) UserTaskExists(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, userTaskExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
