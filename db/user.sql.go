// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: user.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const addRoleToUser = `-- name: AddRoleToUser :one
UPDATE app_users
SET role_id = $1
WHERE id = $2
RETURNING id, username, email, password, role_id, first_name, last_name, created_at, updated_at
`

type AddRoleToUserParams struct {
	RoleID uuid.NullUUID `json:"role_id"`
	ID     uuid.UUID     `json:"id"`
}

func (q *Queries) AddRoleToUser(ctx context.Context, arg AddRoleToUserParams) (AppUser, error) {
	row := q.db.QueryRowContext(ctx, addRoleToUser, arg.RoleID, arg.ID)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.RoleID,
		&i.FirstName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const assignRoleToUser = `-- name: AssignRoleToUser :exec
UPDATE app_users
SET role_id = $1
WHERE id = $2
`

type AssignRoleToUserParams struct {
	RoleID uuid.NullUUID `json:"role_id"`
	ID     uuid.UUID     `json:"id"`
}

func (q *Queries) AssignRoleToUser(ctx context.Context, arg AssignRoleToUserParams) error {
	_, err := q.db.ExecContext(ctx, assignRoleToUser, arg.RoleID, arg.ID)
	return err
}

const createPermission = `-- name: CreatePermission :one
INSERT INTO permissions (name)
VALUES ($1)
RETURNING id, name, code
`

func (q *Queries) CreatePermission(ctx context.Context, name string) (Permission, error) {
	row := q.db.QueryRowContext(ctx, createPermission, name)
	var i Permission
	err := row.Scan(&i.ID, &i.Name, &i.Code)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO "app_users" (
  username,
  first_name,
  last_name,
  email,
  password,
  role_id
) VALUES (
  $1, $2, $3, $4, $5, $6
) RETURNING id, username, email, password, role_id, first_name, last_name, created_at, updated_at
`

type CreateUserParams struct {
	Username  string         `json:"username"`
	FirstName sql.NullString `json:"first_name"`
	LastName  sql.NullString `json:"last_name"`
	Email     string         `json:"email"`
	Password  string         `json:"password"`
	RoleID    uuid.NullUUID  `json:"role_id"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (AppUser, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Password,
		arg.RoleID,
	)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.RoleID,
		&i.FirstName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserCase = `-- name: CreateUserCase :one
INSERT INTO "user_cases" (
  user_id,
  case_id
) VALUES (
  $1, $2
) RETURNING id, user_id, case_id
`

type CreateUserCaseParams struct {
	UserID uuid.UUID `json:"user_id"`
	CaseID uuid.UUID `json:"case_id"`
}

func (q *Queries) CreateUserCase(ctx context.Context, arg CreateUserCaseParams) (UserCase, error) {
	row := q.db.QueryRowContext(ctx, createUserCase, arg.UserID, arg.CaseID)
	var i UserCase
	err := row.Scan(&i.ID, &i.UserID, &i.CaseID)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM "app_users" WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getPermissionsForRole = `-- name: GetPermissionsForRole :many
SELECT permissions.name
FROM permissions
JOIN role_permissions ON role_permissions.permission_id = permissions.id
WHERE role_permissions.role_id = $1
`

func (q *Queries) GetPermissionsForRole(ctx context.Context, roleID uuid.UUID) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getPermissionsForRole, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRolePermissions = `-- name: GetRolePermissions :many
SELECT p.name
FROM role_permissions AS rp
INNER JOIN permissions AS p ON rp.permission_id = p.id
WHERE rp.role_id = $1
`

func (q *Queries) GetRolePermissions(ctx context.Context, roleID uuid.UUID) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getRolePermissions, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, username, email, password, role_id, first_name, last_name, created_at, updated_at FROM "app_users" WHERE id = $1
`

func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (AppUser, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.RoleID,
		&i.FirstName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, password, role_id, first_name, last_name, created_at, updated_at FROM "app_users" WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (AppUser, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.RoleID,
		&i.FirstName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email, password, role_id, first_name, last_name, created_at, updated_at FROM "app_users" WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (AppUser, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.RoleID,
		&i.FirstName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, password, role_id, first_name, last_name, created_at, updated_at FROM "app_users" WHERE username = $1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (AppUser, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.RoleID,
		&i.FirstName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserCaseID = `-- name: GetUserCaseID :one
SELECT id FROM "user_cases" WHERE case_id = $1
`

func (q *Queries) GetUserCaseID(ctx context.Context, caseID uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getUserCaseID, caseID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getUserWithRole = `-- name: GetUserWithRole :one
SELECT u.id, u.username, u.email, u.password, u.role_id, u.first_name, u.last_name, u.created_at, u.updated_at, r.name as role_name
FROM app_users AS u
LEFT JOIN role AS r ON u.role_id = r.id
WHERE u.username = $1
`

type GetUserWithRoleRow struct {
	ID        uuid.UUID      `json:"id"`
	Username  string         `json:"username"`
	Email     string         `json:"email"`
	Password  string         `json:"password"`
	RoleID    uuid.NullUUID  `json:"role_id"`
	FirstName sql.NullString `json:"first_name"`
	LastName  sql.NullString `json:"last_name"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
	RoleName  sql.NullString `json:"role_name"`
}

func (q *Queries) GetUserWithRole(ctx context.Context, username string) (GetUserWithRoleRow, error) {
	row := q.db.QueryRowContext(ctx, getUserWithRole, username)
	var i GetUserWithRoleRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.RoleID,
		&i.FirstName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RoleName,
	)
	return i, err
}

const getUsers = `-- name: GetUsers :many
SELECT id, username, email, password, role_id, first_name, last_name, created_at, updated_at FROM app_users
`

func (q *Queries) GetUsers(ctx context.Context) ([]AppUser, error) {
	rows, err := q.db.QueryContext(ctx, getUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AppUser{}
	for rows.Next() {
		var i AppUser
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.RoleID,
			&i.FirstName,
			&i.LastName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithRoles = `-- name: GetUsersWithRoles :many
SELECT app_users.id, app_users.username, app_users.email, app_users.password, app_users.role_id, app_users.first_name, app_users.last_name, app_users.created_at, app_users.updated_at, role.name AS role_name
FROM app_users
INNER JOIN role ON app_users.role_id = role.id
`

type GetUsersWithRolesRow struct {
	ID        uuid.UUID      `json:"id"`
	Username  string         `json:"username"`
	Email     string         `json:"email"`
	Password  string         `json:"password"`
	RoleID    uuid.NullUUID  `json:"role_id"`
	FirstName sql.NullString `json:"first_name"`
	LastName  sql.NullString `json:"last_name"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
	RoleName  string         `json:"role_name"`
}

func (q *Queries) GetUsersWithRoles(ctx context.Context) ([]GetUsersWithRolesRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersWithRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersWithRolesRow{}
	for rows.Next() {
		var i GetUsersWithRolesRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.RoleID,
			&i.FirstName,
			&i.LastName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RoleName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, username, email, password, role_id, first_name, last_name, created_at, updated_at FROM "app_users"
`

func (q *Queries) ListUsers(ctx context.Context) ([]AppUser, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AppUser{}
	for rows.Next() {
		var i AppUser
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.RoleID,
			&i.FirstName,
			&i.LastName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :one
UPDATE app_users
SET
  username = $1,
  first_name = $2,
  last_name = $3,
  email = $4,
  password = $5,
  role_id = $6
WHERE id = $7
RETURNING id, username, email, password, role_id, first_name, last_name, created_at, updated_at
`

type UpdateUserParams struct {
	Username  string         `json:"username"`
	FirstName sql.NullString `json:"first_name"`
	LastName  sql.NullString `json:"last_name"`
	Email     string         `json:"email"`
	Password  string         `json:"password"`
	RoleID    uuid.NullUUID  `json:"role_id"`
	ID        uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (AppUser, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Password,
		arg.RoleID,
		arg.ID,
	)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.RoleID,
		&i.FirstName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :one
UPDATE app_users
SET password = $1
WHERE id = $2
RETURNING id, username, email, password, role_id, first_name, last_name, created_at, updated_at
`

type UpdateUserPasswordParams struct {
	Password string    `json:"password"`
	ID       uuid.UUID `json:"id"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (AppUser, error) {
	row := q.db.QueryRowContext(ctx, updateUserPassword, arg.Password, arg.ID)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.RoleID,
		&i.FirstName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const userExists = `-- name: UserExists :one
SELECT EXISTS(SELECT 1 FROM "app_users" WHERE username = $1)
`

func (q *Queries) UserExists(ctx context.Context, username string) (bool, error) {
	row := q.db.QueryRowContext(ctx, userExists, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userExistsByID = `-- name: UserExistsByID :one
SELECT EXISTS(SELECT 1 FROM "app_users" WHERE id = $1)
`

func (q *Queries) UserExistsByID(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, userExistsByID, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
